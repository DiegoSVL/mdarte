// license-header java merge-point
// Generated by: ControleAcessoImpl.vsl in andromda-ejb-cartridge.
//

#set ($generatedFile = "ControleAcessoImpl.java")
#if($stringUtils.isNotEmpty($controleAcessoDir))
package $controleAcessoDir;
#set ($generatedFile = "${stringUtils.replace($controleAcessoDir,'.','/')}/${generatedFile}")
#end
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;

import accessControl.Perfil;
import accessControl.exception.ControleAcessoException;
#if($controleAcessoDefault == 'true')
import br.gov.mdarte.controleacesso.cd.*;
#end

public  class ControleAcessoImpl extends accessControl.ControleAcesso {
#if($controleAcessoDefault == 'true')
	public static final String SUPER_USUARIO = "1";
	public static final int PROXIMA_TROCA_SENHA_DIAS = 30;
	/**
	 * Verifica se o operador necessita trocar senha obrigatoria
	 */
	@Override
	public boolean precisaTrocarSenha(accessControl.Operador operador) throws ControleAcessoException{
		return false;
	}
	
	/**
	 * Recupera o operador de acordo com o login
	 */
	@Override
	public accessControl.Operador getOperador(String usuario) throws ControleAcessoException{
		
		UsuarioDAOImpl usuarioDAO = new UsuarioDAOImpl();
		
		try
		{
			return (accessControl.Operador) usuarioDAO.recuperarUsuario(usuario);
		}
		catch (br.gov.mdarte.controleacesso.cd.DAOException e)
		{
			throw new ControleAcessoException(e.getMessage());
		}
	}

	private HashMap<String, Collection<accessControl.Perfil>> addServices(HashMap<String,Collection<accessControl.Perfil>> hmServicos, Acao acao, Collection<accessControl.Perfil> perfis)
	{
		if (hmServicos.get(acao.getCodigo()) != null)
		{
			hmServicos.get(acao.getCodigo()).addAll(perfis);
		}
		else
		{
			hmServicos.put(acao.getCodigo(), perfis);
		}
		
		for(Acao acaoAgrupada : (Collection<Acao>) acao.getEAgrupadoPor())
		{
			hmServicos = addServices(hmServicos, acaoAgrupada, perfis);
		}
		return hmServicos;
	}

	/**
	 * lista os servicos em um map onde a chave eh o nome do servico e o valor a colecao de perfis que possui acesso ao servico
	 */
	@Override
	public java.util.HashMap<String, java.util.Collection<accessControl.Perfil>> listaServicos() throws ControleAcessoException {
		
		HashMap<String, Collection<accessControl.Perfil>> hmServicos = new HashMap<String, Collection<accessControl.Perfil>>();
		
		AcaoDAOImpl acaoDAO = new AcaoDAOImpl();
		
		List acaoList = new ArrayList();
		
		try
		{
			// recupera todos os serviços
			acaoList = acaoDAO.list();
		}
		catch(br.gov.mdarte.controleacesso.cd.DAOException e)
		{
			throw new ControleAcessoException(e.getMessage());
		}
		
		for(Acao acao : (Collection<Acao>) acaoList)
		{
			Collection<Perfil> perfilAcaoList = acao.getPerfils();
			Collection<accessControl.Perfil> perfilList = new HashSet<accessControl.Perfil>();
			// adiciona SU para todos os servicos
			perfilList.add(new accessControl.Perfil(SUPER_USUARIO));
			
			for(Perfil perfilCA : perfilAcaoList)
			{
				accessControl.Perfil perfil = new accessControl.Perfil(perfilCA.getId().toString());
				perfilList.add(perfil);
			}
			
			if (!perfilList.isEmpty()) hmServicos = addServices(hmServicos, acao, perfilList);
		}

		return hmServicos;
	}	

	/**
	 * realiza a troca de senha do operador
	 */
	@Override
	public boolean trocaSenha(accessControl.Operador operador, String senhaAtual, String novaSenha) throws ControleAcessoException{
		
		UsuarioDAOImpl usrDAO = new UsuarioDAOImpl();
		UsuarioImpl usrRetrieved;
		UsuarioImpl usr = (UsuarioImpl) operador;
		usrRetrieved = (UsuarioImpl) getOperador(usr.getLogin());
		
		if (!usrRetrieved.getSenha().equals(senhaAtual)) return false;
		
		usrRetrieved.setSenha(novaSenha);
		Calendar calendar = new GregorianCalendar();
		calendar.add(Calendar.DATE, PROXIMA_TROCA_SENHA_DIAS);
		usrRetrieved.setDataValidadeSenha(calendar.getTime());
		
		try
		{
			usrDAO.update(usrRetrieved);
		}
		catch (br.gov.mdarte.controleacesso.cd.DAOException e)
		{
			e.printStackTrace();
			return false;
		}

		return true;
	}	

	/**
	 * Bloqueia o acesso do usuário
	 */
	@Override
	public void bloqueiaUsuario(String usuario) {
		
	}		

	/**
	 * Verifica se o acesso do usuário está bloqueado
	 */
	@Override
	public boolean usuarioBloqueado(String usuario) {
		return false;
	}	

	/**
	 * Verifica se a senha é fraca
	 */
	@Override
	public boolean senhaFraca(String senha) {
		
		/* IMPLEMENTACAO SUGERIDA
		 *
		 * (a senha deve possuir pelo menos 8 caracteres,
		 * incluindo numerais, letras maiúsculas,
		 * letras minúsculas e símbolos)
		 */
		 
		if (senha == null) {
			return true;
		}
		
		if (senha.length() < 8) {
			return true;
		}
		
		String numerais = "0123456789";
		String maiusculas = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
		String minusculas = "abcdefghijklmnopqrstuvwxyz";
		String simbolos = " !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";

		boolean achouNumeral = false;
		boolean achouMaiuscula = false;
		boolean achouMinuscula = false;
		boolean achouSimbolo = false;
		
		for (int i = 0; i < senha.length(); i++) {
			achouNumeral |= numerais.indexOf(senha.charAt(i)) > -1;
			achouMaiuscula |= maiusculas.indexOf(senha.charAt(i)) > -1;
			achouMinuscula |= minusculas.indexOf(senha.charAt(i)) > -1;
			achouSimbolo |= simbolos.indexOf(senha.charAt(i)) > -1;
		}
		
		return !achouNumeral || !achouMaiuscula || !achouMinuscula || !achouSimbolo;
		
	}
	
	/**
	 * lista as restricoes em um map onde a chave eh o perfil e o valor a colecao de restricoes do perfil
	 */
	@Override
	public java.util.HashMap<String,java.util.Collection<accessControl.Restricao>> getRestricoes(accessControl.Operador operador, accessControl.Servico servico) throws ControleAcessoException {
		// TODO Auto-generated method stub
		return null;
	}	
	
	/**
	*	Busca os perfis associados ao servico
	*/
	@Override
	public  java.util.Collection<accessControl.Perfil> buscaPerfisServico(accessControl.Servico servico) throws ControleAcessoException{
		
		return null;
	}
	
	public  static class RestricaoDinamicaImpl {
#foreach ($service in $services)
#foreach ($operation in $service.operations )
	
		$operation.visibility  $operation.returnType.fullyQualifiedName ${operation.name} () {
#if ($operation.returnTypePresent)
                    return $operation.returnType.javaNullString;
#end
		}
	
#end

#end
	}	

	public void agendaTarefas() {
	
	}
#else
	@Override
	public boolean precisaTrocarSenha(accessControl.Operador operador) throws ControleAcessoException{
		return false;
	}
	
	/**
	 * Recupera o operador de acordo com o login
	 */
	@Override
	public accessControl.Operador getOperador(String usuario) throws ControleAcessoException{
		return null;
	}

	/**
	 * lista os servicos em um map onde a chave eh o nome do servico e o valor a colecao de perfis que possui acesso ao servico
	 */
	@Override
	public java.util.HashMap<String, java.util.Collection<accessControl.Perfil>> listaServicos() throws ControleAcessoException {
		return null;
	}	

	/**
	 * realiza a troca de senha do operador
	 */
	@Override
	public boolean trocaSenha(accessControl.Operador operador, String senhaAtual, String novaSenha) throws ControleAcessoException{
		return false;
		
	}

	/**
	 * Bloqueia o acesso do usuário
	 */
	@Override
	public void bloqueiaUsuario(String usuario) {
		
	}

	/**
	 * Verifica se o acesso do usuário está bloqueado
	 */
	@Override
	public boolean usuarioBloqueado(String usuario) {
		return false;
	}	

	/**
	 * Verifica se a senha é fraca
	 */
	@Override
	public boolean senhaFraca(String senha) {
		return false;
		
		/* IMPLEMENTACAO SUGERIDA
		 *
		 * (a senha deve possuir pelo menos 8 caracteres,
		 * incluindo numerais, letras maiúsculas,
		 * letras minúsculas e símbolos)
		 
		 
		if (senha == null) {
			return true;
		}
		
		if (senha.length() < 8) {
			return true;
		}
		
		String numerais = "0123456789";
		String maiusculas = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
		String minusculas = "abcdefghijklmnopqrstuvwxyz";
		String simbolos = " !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";

		boolean achouNumeral = false;
		boolean achouMaiuscula = false;
		boolean achouMinuscula = false;
		boolean achouSimbolo = false;
		
		for (int i = 0; i < senha.length(); i++) {
			achouNumeral |= numerais.indexOf(senha.charAt(i)) > -1;
			achouMaiuscula |= maiusculas.indexOf(senha.charAt(i)) > -1;
			achouMinuscula |= minusculas.indexOf(senha.charAt(i)) > -1;
			achouSimbolo |= simbolos.indexOf(senha.charAt(i)) > -1;
		}
		
		return !achouNumeral || !achouMaiuscula || !achouMinuscula || !achouSimbolo;
		*/
	}
	
	/**
	 * lista as restricoes em um map onde a chave eh o perfil e o valor a colecao de restricoes do perfil
	 */
	@Override
	public java.util.HashMap<String,java.util.Collection<accessControl.Restricao>> getRestricoes(accessControl.Operador operador, accessControl.Servico servico) throws ControleAcessoException {
		return null;
	}	
	
	/**
	*	Busca os perfis associados ao servico
	*/
	@Override
	public  java.util.Collection<accessControl.Perfil> buscaPerfisServico(accessControl.Servico servico) throws ControleAcessoException{
		
		return null;
	}
	
	public  static class RestricaoDinamicaImpl {
#foreach ($service in $services)
#foreach ($operation in $service.operations )
	
		$operation.visibility  $operation.returnType.fullyQualifiedName ${operation.name} () {
#if ($operation.returnTypePresent)
                    return $operation.returnType.javaNullString;
#end
		}
#end

#end
	}

	public void agendaTarefas() {

	}
#end
}