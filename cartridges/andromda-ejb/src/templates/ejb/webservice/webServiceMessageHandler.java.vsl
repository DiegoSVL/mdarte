#if ($webServiceComAutenticacao.equalsIgnoreCase("true"))
#if ($stringUtils.isNotBlank(${service.packageName}))
package ${service.packageName};
#end

import java.io.ByteArrayOutputStream;
import java.lang.reflect.Method;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import javax.security.auth.Subject;
import javax.security.auth.login.LoginContext;

#if($service.jaxws)
import javax.xml.ws.handler.MessageContext;
import javax.xml.ws.handler.soap.SOAPHandler;
import javax.xml.ws.handler.soap.SOAPMessageContext;
#else
import javax.xml.rpc.handler.GenericHandler;
import javax.xml.rpc.handler.HandlerInfo;
import javax.xml.rpc.handler.MessageContext;
import javax.xml.rpc.handler.soap.SOAPMessageContext;
#end

import javax.xml.namespace.QName;
import javax.xml.soap.SOAPBody;
import javax.xml.soap.SOAPElement;
import javax.xml.soap.SOAPEnvelope;
import javax.xml.soap.SOAPException;
import javax.xml.soap.SOAPHeader;
import javax.xml.soap.SOAPMessage;
import javax.xml.soap.SOAPPart;

import org.apache.commons.codec.binary.Base64;
import org.apache.log4j.Logger;
import accessControl.ControleAcesso;
import accessControl.LoginCallbackHandler;
import accessControl.PrincipalImpl;
import accessControl.Servico;
import accessControl.ServicosSingleton;
import br.gov.controleacesso.cd.OperadorCa;
import br.gov.controleacesso.cd.OperadorCaDAO;
import br.gov.controleacesso.cd.OperadorCaDAOImpl;
import br.gov.controleacesso.vo.OperadorCaVO;
import java.util.concurrent.ConcurrentHashMap;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.Transformer;
import javax.xml.transform.Source;
import javax.xml.transform.stream.StreamResult;

public class ${service.name}MessageHandler extends GenericHandler {
    private static final long TEMPO_VALIDADE_TOKEN = 30000L;
    private static final long TEMPO_EXPIRADO_TOKEN = 60000L;
    private static final String URI_PASSWORD_DIGEST = "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordDigest";
    private static ConcurrentHashMap<String, Calendar> mapaChaveUnica = new ConcurrentHashMap<String, Calendar>();
    private QName[] headers = null;

	public static final Logger logger = Logger.getLogger(${service.name}MessageHandler.class);
	
    public QName[] getHeaders() {
        return this.headers;
    }

    public void init( HandlerInfo handlerInfo ) {
        this.headers = handlerInfo.getHeaders();
    }

    public boolean handleRequest(MessageContext messageContext) {
        Iterator iteratorCabecalho;
        String nomeRecurso = "${service.packageName}.${service.name}BI";
        /*
         * Recupera o cabeçalho da requisição SOAP
         */
        try {
            SOAPMessageContext soapMessageContext = (SOAPMessageContext) messageContext;
            SOAPMessage soapMessage = soapMessageContext.getMessage();
            SOAPPart soapPart = soapMessage.getSOAPPart();
            SOAPEnvelope soapEnvelope = soapPart.getEnvelope();
            SOAPHeader soapHeader = soapEnvelope.getHeader();
            SOAPBody soapBody = soapEnvelope.getBody();
            if (soapHeader == null || soapHeader.getChildElements() == null || ! soapHeader.getChildElements().hasNext()) {
                throw new JAXRPCException("web.service.erro.nao.ha.informacoes.no.cabecalho.da.mensagem");
            }
            iteratorCabecalho = soapHeader.extractAllHeaderElements();
            // Recupera o nome do método solicitado
            Iterator iteratorCorpo = soapBody.getChildElements();
            SOAPElement element = (SOAPElement) iteratorCorpo.next();
   
            nomeRecurso = this.getNomeRecurso(nomeRecurso, element.getNodeName());
        } catch (SOAPException ex) {
            throw new JAXRPCException(ex);
        } catch (ClassNotFoundException ex) {
            throw new JAXRPCException(ex);
        }
        // Recupera os elementos da tag <wsse:Security>
        iteratorCabecalho = ((SOAPElement) iteratorCabecalho.next()).getChildElements();
        // Recupera os elementos da tag <wsse:UsernameToken>
        iteratorCabecalho = ((SOAPElement) iteratorCabecalho.next()).getChildElements();
        // Recupera os dados da tag <wsse:Username>
        String wsseUsername = this.getValor(iteratorCabecalho);
        // Recupera os dados da tag <wsse:Password>
        String[] wssePassword = this.getValor(iteratorCabecalho, new String[]{"Type"});
        // Recupera os dados da tag <wsse:Nonce>
        String wsseNonce = this.getValor(iteratorCabecalho);
        // Recupera os dados da tag <wsu:Created>
        String wcuCreated = this.getValor(iteratorCabecalho);
        /*
         * Valida o formato da data de criação do cabeçalho
         */
        Calendar dataToken = Calendar.getInstance();
        long dataAvaliacao = dataToken.getTimeInMillis();
        try {
            DateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ");
            if ( wcuCreated.contains( "Z" ) ) {
            	dataToken.setTime(format.parse(wcuCreated.replace( "Z", "+0000" )));
            }
            else {
            	dataToken.setTime(format.parse(wcuCreated));
            }
            dataAvaliacao -= dataToken.getTimeInMillis();
        } catch (ParseException ex) {
            throw new JAXRPCException("web.service.erro.formato.de.data.incompativel", ex);
        }
        /*
         * Gera o token interno conforme especifição OASIS Standards
         * para WS-Security baseado em UsernameToken.
         */
        String senha = this.getPassword(wsseUsername);
        String tokenInterno = this.getUsernameToken(wsseNonce, wcuCreated, senha);
        /*
         * 1a. Regra: A senha da requisição deverá ser igual ao token gerado internamente,
         * bem como o algoritmo deverá ser 'Password Digest'.
         */
        if (!(tokenInterno.equals(wssePassword[0])) || ! (URI_PASSWORD_DIGEST.equals(wssePassword[1]))) {
            throw new JAXRPCException("web.service.erro.credenciais.invalidas");
        }
        /*
         * 2a. Regra: A chave única não poderá ter sido usada anteriormente.
         */
        if (mapaChaveUnica.containsKey(wsseNonce)) {
            throw new JAXRPCException("web.service.erro.credenciais.ja.utilizadas");
        }
        /*
         * 3a. Regra: O tempo de criação do token deverá ter um tempo curto de validade.
         */
        if ( dataAvaliacao > TEMPO_VALIDADE_TOKEN ) {
        	throw new JAXRPCException("web.service.erro.credenciais.expiradas");
		}

        /*
         * 4a. Regra: Toda chave única utilizada deverá ser registrada com um tempo de
         * existência maior que o tempo de validade.
         */
        mapaChaveUnica.put(wsseNonce, dataToken);
        removeChavesQueUltrapassaramTempoDeVida();
         /*
          * 5a. Regra: O usuário deve possuir uma autorização
          * específica para acessar o método de serviço.
          */
        this.autenticarUsuario(wsseUsername, senha, nomeRecurso);
        
		String messageContentAsString = getMessageAsString(messageContext);
		logger.info("SOAP REQUEST" + "\t" + wsseUsername + "\t" + nomeRecurso + "\t" + messageContentAsString);
		
        return true;
    }

	public boolean handleResponse(MessageContext messageContext) {
		String messageContentAsString = getMessageAsString(messageContext);
		logger.info("SOAP RESPONSE" + "\t" + messageContentAsString);
		return true;
	}    
	
	private void removeChavesQueUltrapassaramTempoDeVida() {
		synchronized (mapaChaveUnica) {
			Object[] chavesUnicas = mapaChaveUnica.keySet().toArray();
	        for (int i = 0; i < chavesUnicas.length; i++) {
	            String token = (String) chavesUnicas[i];
	            Calendar data = (Calendar) mapaChaveUnica.get(token);
	            long tempo = Calendar.getInstance().getTimeInMillis() - data.getTimeInMillis();
	            if (tempo > TEMPO_EXPIRADO_TOKEN) {
	                mapaChaveUnica.remove(token);
	            }
	         }
		}
	}  
	
    private String getNomeRecurso( String nomeClasse, String nomeMetodo ) throws ClassNotFoundException {
        if ( nomeMetodo.indexOf( ":" ) > 0 ) {
            nomeMetodo = nomeMetodo.substring( nomeMetodo.indexOf( ":" ) + 1 );
        }

        String nomeRecurso = nomeClasse.concat( "." ).concat( nomeMetodo ).concat( "(" );
        Class classe = Class.forName( nomeClasse );
        for ( Method metodo : classe.getMethods() ) {
            if ( metodo.getName().equals( nomeMetodo ) ) {
                Boolean primeiraOcorrencia = Boolean.TRUE;
                for ( Class parametro : metodo.getParameterTypes() ) {
                    if ( !primeiraOcorrencia ) {
                        nomeRecurso = nomeRecurso.concat( ", " );
                    }
                    nomeRecurso = nomeRecurso.concat( parametro.getName() );
                    primeiraOcorrencia = Boolean.FALSE;
                }
            }
        }
        return nomeRecurso.concat( ")" );
    }

    private String getValor( Iterator iterator ) {
        return this.getValor( iterator, null )[ 0 ];
    }

    private String[] getValor( Iterator iterator, String[] atributos ) {
        if ( !( iterator.hasNext() ) ) {
            throw new JAXRPCException("web.service.erro.credenciais.inclompetas");
        }
        SOAPElement campo = ( SOAPElement ) iterator.next();
        String valor = campo.getValue();
        if ( valor == null ) {
            throw new JAXRPCException("web.service.erro.credenciais.inclompetas");
        }
        if ( atributos == null ) {
            return new String[] { valor };
        }
        String[] retorno = new String[atributos.length + 1];
        retorno[ 0 ] = valor;
        for ( int i = 0; i < atributos.length; i++ ) {
            retorno[ i + 1 ] = campo.getAttribute( atributos[ i ] );
        }
        return retorno;
    }
    /*
     * Implementação do algoritmo para uso do WS-Security baseado em UsernameToken
     * (versão 1.0), conforme especificação da OASIS Standards (março/2004).
     *
     * PASSWORD_DIGEST = BASE64 ( SHA1 ( nonce + created + password ) )
     */
    private String getUsernameToken( String nonce, String created, String password ) throws JAXRPCException {
		String passwdDigest = null;
        try {
    		byte[] b1 = nonce != null ? Base64.decodeBase64( nonce ) : new byte[0];
    		byte[] b2 = created != null ? created.getBytes( "UTF-8" ) : new byte[0];
    		byte[] b3 = password.getBytes( "UTF-8" );
    		byte[] b4 = new byte[b1.length + b2.length + b3.length];
    		int offset = 0;
    		System.arraycopy( b1, 0, b4, offset, b1.length );
    		offset += b1.length;

    		System.arraycopy( b2, 0, b4, offset, b2.length );
    		offset += b2.length;

    		System.arraycopy( b3, 0, b4, offset, b3.length );

    		MessageDigest sha = MessageDigest.getInstance( "SHA-1" );
    		sha.reset();
    		sha.update( b4 );
    		passwdDigest = Base64.encodeBase64String( sha.digest() );
    		passwdDigest = passwdDigest.replace( "\r", "" );
    		passwdDigest = passwdDigest.replace( "\n", "" );
        } catch ( Exception ex ) {
            throw new JAXRPCException("web.service.erro.falha.algoritmo.seguranca", ex);
        }
        return passwdDigest;
    }

    private String getPassword( String usuario ) {
        OperadorCaVO vo = new OperadorCaVO();
        OperadorCaDAO dao = new OperadorCaDAOImpl();
        vo.setLogin( usuario );
        List usuarios;
        try {
            usuarios = dao.filter( vo, null );
        } catch ( Exception e1 ) {
            usuarios = new ArrayList();
        }
        if ( usuarios.isEmpty() ) {
            throw new JAXRPCException("web.service.erro.nao.foi.encontrado.um.usuario.no.sistema.com.as.credenciais.informadas");
        }
        OperadorCa opca = ( OperadorCa ) usuarios.get( 0 );
        return opca.getSenha();
    }

    private void autenticarUsuario( String usuario, String senha, String recurso ) {
        LoginContext loginCtx;

        try {
            loginCtx = new LoginContext("${securityRealm}-ws", new LoginCallbackHandler(usuario, senha));
            loginCtx.login();
        } catch ( Exception ex ) {
            throw new JAXRPCException( ex );
        }

        HashMap servicos = ServicosSingleton.instance().getServicos();
        HashMap mapServicos;
        if ( servicos == null ) {
            mapServicos = new HashMap();
        } else {
            mapServicos = (HashMap) servicos.get("${securityRealm}");
        }
        Subject subject = loginCtx.getSubject();
        Servico servico = new Servico( recurso );

        PrincipalImpl principalImpl = ControleAcesso.getCallerPrincipal( subject );
        principalImpl.setNomeProjeto("${securityRealm}");

        try {
            if ( ControleAcesso.verificaPermissao( subject, mapServicos, servico, true ) ) {
                return;
            }
        } catch ( Exception ex ) {
            throw new JAXRPCException( ex );
        }
        throw new JAXRPCException("web.service.erro.usuario.sem.perfil.para.executar.este.metodo," + servico.getNome());        
    }
    
	private String getMessageAsString(MessageContext context) {
		try {
			// get the soap header
			SOAPMessageContext smc = (SOAPMessageContext) context;
			SOAPMessage soapMessage = smc.getMessage();

			// Create transformer
			TransformerFactory tff = TransformerFactory.newInstance();
			Transformer tf = tff.newTransformer();

			// Get reply content
			Source sc = soapMessage.getSOAPPart().getContent();

			// Set output transformation
			ByteArrayOutputStream streamOut = new ByteArrayOutputStream();
			StreamResult result = new StreamResult(streamOut);
			tf.transform(sc, result);

			String strMessage = streamOut.toString();
			
			String operation = soapMessage.getSOAPBody().getFirstChild().getLocalName();

			return operation + "\t" + strMessage;			
		} catch (Exception e) {
			throw new JAXRPCException(e);
		}
	}        
}
#end